"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_vite_dist_node_chunks_dep-9deb2354_js"],{

/***/ "./node_modules/vite/dist/node/chunks/dep-07a79996.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-07a79996.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"l\": () => (/* binding */ lib)\n/* harmony export */ });\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ \"node:module\");\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_0__.fileURLToPath)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-07a79996.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-07a79996.js\");\nconst __require = require;\nvar openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nvar parse$1 = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n\nvar walk$1 = function walk(nodes, cb, bubble) {\n  var i, max, node, result;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n    if (!bubble) {\n      result = cb(node, i, nodes);\n    }\n\n    if (\n      result !== false &&\n      node.type === \"function\" &&\n      Array.isArray(node.nodes)\n    ) {\n      walk(node.nodes, cb, bubble);\n    }\n\n    if (bubble) {\n      cb(node, i, nodes);\n    }\n  }\n};\n\nfunction stringifyNode(node, custom) {\n  var type = node.type;\n  var value = node.value;\n  var buf;\n  var customResult;\n\n  if (custom && (customResult = custom(node)) !== undefined) {\n    return customResult;\n  } else if (type === \"word\" || type === \"space\") {\n    return value;\n  } else if (type === \"string\") {\n    buf = node.quote || \"\";\n    return buf + value + (node.unclosed ? \"\" : buf);\n  } else if (type === \"comment\") {\n    return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n  } else if (type === \"div\") {\n    return (node.before || \"\") + value + (node.after || \"\");\n  } else if (Array.isArray(node.nodes)) {\n    buf = stringify$1(node.nodes, custom);\n    if (type !== \"function\") {\n      return buf;\n    }\n    return (\n      value +\n      \"(\" +\n      (node.before || \"\") +\n      buf +\n      (node.after || \"\") +\n      (node.unclosed ? \"\" : \")\")\n    );\n  }\n  return value;\n}\n\nfunction stringify$1(nodes, custom) {\n  var result, i;\n\n  if (Array.isArray(nodes)) {\n    result = \"\";\n    for (i = nodes.length - 1; ~i; i -= 1) {\n      result = stringifyNode(nodes[i], custom) + result;\n    }\n    return result;\n  }\n  return stringifyNode(nodes, custom);\n}\n\nvar stringify_1 = stringify$1;\n\nvar unit;\nvar hasRequiredUnit;\n\nfunction requireUnit () {\n\tif (hasRequiredUnit) return unit;\n\thasRequiredUnit = 1;\n\tvar minus = \"-\".charCodeAt(0);\n\tvar plus = \"+\".charCodeAt(0);\n\tvar dot = \".\".charCodeAt(0);\n\tvar exp = \"e\".charCodeAt(0);\n\tvar EXP = \"E\".charCodeAt(0);\n\n\t// Check if three code points would start a number\n\t// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number\n\tfunction likeNumber(value) {\n\t  var code = value.charCodeAt(0);\n\t  var nextCode;\n\n\t  if (code === plus || code === minus) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    var nextNextCode = value.charCodeAt(2);\n\n\t    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code === dot) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code >= 48 && code <= 57) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t}\n\n\t// Consume a number\n\t// https://www.w3.org/TR/css-syntax-3/#consume-number\n\tunit = function(value) {\n\t  var pos = 0;\n\t  var length = value.length;\n\t  var code;\n\t  var nextCode;\n\t  var nextNextCode;\n\n\t  if (length === 0 || !likeNumber(value)) {\n\t    return false;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\n\t  if (code === plus || code === minus) {\n\t    pos++;\n\t  }\n\n\t  while (pos < length) {\n\t    code = value.charCodeAt(pos);\n\n\t    if (code < 48 || code > 57) {\n\t      break;\n\t    }\n\n\t    pos += 1;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\n\t  if (code === dot && nextCode >= 48 && nextCode <= 57) {\n\t    pos += 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\t  nextNextCode = value.charCodeAt(pos + 2);\n\n\t  if (\n\t    (code === exp || code === EXP) &&\n\t    ((nextCode >= 48 && nextCode <= 57) ||\n\t      ((nextCode === plus || nextCode === minus) &&\n\t        nextNextCode >= 48 &&\n\t        nextNextCode <= 57))\n\t  ) {\n\t    pos += nextCode === plus || nextCode === minus ? 3 : 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  return {\n\t    number: value.slice(0, pos),\n\t    unit: value.slice(pos)\n\t  };\n\t};\n\treturn unit;\n}\n\nvar parse = parse$1;\nvar walk = walk$1;\nvar stringify = stringify_1;\n\nfunction ValueParser(value) {\n  if (this instanceof ValueParser) {\n    this.nodes = parse(value);\n    return this;\n  }\n  return new ValueParser(value);\n}\n\nValueParser.prototype.toString = function() {\n  return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\n\nValueParser.prototype.walk = function(cb, bubble) {\n  walk(this.nodes, cb, bubble);\n  return this;\n};\n\nValueParser.unit = requireUnit();\n\nValueParser.walk = walk;\n\nValueParser.stringify = stringify;\n\nvar lib = ValueParser;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC0wN2E3OTk5Ni5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQ1g7QUFDYzs7QUFFbkUsbUJBQW1CLHVEQUFtQixDQUFDLDZGQUFlO0FBQ3RELGtCQUFrQixrREFBYTtBQUMvQixnQkFBZ0IsMERBQW1CLENBQUMsNkZBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC0wN2E3OTk5Ni5qcz85Nzc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG52YXIgb3BlblBhcmVudGhlc2VzID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbnZhciBjbG9zZVBhcmVudGhlc2VzID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzaW5nbGVRdW90ZSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgZG91YmxlUXVvdGUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgYmFja3NsYXNoID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzbGFzaCA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgY29tbWEgPSBcIixcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNvbG9uID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbnZhciBzdGFyID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbnZhciB1TG93ZXIgPSBcInVcIi5jaGFyQ29kZUF0KDApO1xudmFyIHVVcHBlciA9IFwiVVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgcGx1cyA9IFwiK1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgaXNVbmljb2RlUmFuZ2UgPSAvXlthLWYwLTk/LV0rJC9pO1xuXG52YXIgcGFyc2UkMSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgdmFyIG5leHQsXG4gICAgcXVvdGUsXG4gICAgcHJldixcbiAgICB0b2tlbixcbiAgICBlc2NhcGUsXG4gICAgZXNjYXBlUG9zLFxuICAgIHdoaXRlc3BhY2VQb3MsXG4gICAgcGFyZW50aGVzZXNPcGVuUG9zO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gIHZhciBtYXggPSB2YWx1ZS5sZW5ndGg7XG4gIHZhciBzdGFjayA9IFt7IG5vZGVzOiB0b2tlbnMgfV07XG4gIHZhciBiYWxhbmNlZCA9IDA7XG4gIHZhciBwYXJlbnQ7XG5cbiAgdmFyIG5hbWUgPSBcIlwiO1xuICB2YXIgYmVmb3JlID0gXCJcIjtcbiAgdmFyIGFmdGVyID0gXCJcIjtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgLy8gV2hpdGVzcGFjZXNcbiAgICBpZiAoY29kZSA8PSAzMikge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgdG9rZW4gPSB2YWx1ZS5zbGljZShwb3MsIG5leHQpO1xuXG4gICAgICBwcmV2ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjb2RlID09PSBjbG9zZVBhcmVudGhlc2VzICYmIGJhbGFuY2VkKSB7XG4gICAgICAgIGFmdGVyID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcImRpdlwiKSB7XG4gICAgICAgIHByZXYuYWZ0ZXIgPSB0b2tlbjtcbiAgICAgICAgcHJldi5zb3VyY2VFbmRJbmRleCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICBjb2RlID09PSBjb2xvbiB8fFxuICAgICAgICAoY29kZSA9PT0gc2xhc2ggJiZcbiAgICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KG5leHQgKyAxKSAhPT0gc3RhciAmJlxuICAgICAgICAgICghcGFyZW50IHx8XG4gICAgICAgICAgICAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFyZW50LnZhbHVlICE9PSBcImNhbGNcIikpKVxuICAgICAgKSB7XG4gICAgICAgIGJlZm9yZSA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcblxuICAgICAgLy8gUXVvdGVzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZSB8fCBjb2RlID09PSBkb3VibGVRdW90ZSkge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIHF1b3RlID0gY29kZSA9PT0gc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgcXVvdGU6IHF1b3RlXG4gICAgICB9O1xuICAgICAgZG8ge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAodmFsdWUuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHF1b3RlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZXNjYXBlKTtcbiAgICAgIHRva2VuLnZhbHVlID0gdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dCk7XG4gICAgICB0b2tlbi5zb3VyY2VFbmRJbmRleCA9IHRva2VuLnVuY2xvc2VkID8gbmV4dCA6IG5leHQgKyAxO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBDb21tZW50c1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gc2xhc2ggJiYgdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gc3Rhcikge1xuICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YoXCIqL1wiLCBwb3MpO1xuXG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0ICsgMlxuICAgICAgfTtcblxuICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdG9rZW4uc291cmNlRW5kSW5kZXggPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnNsaWNlKHBvcyArIDIsIG5leHQpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBwb3MgPSBuZXh0ICsgMjtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZXJhdGlvbiB3aXRoaW4gY2FsY1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoY29kZSA9PT0gc2xhc2ggfHwgY29kZSA9PT0gc3RhcikgJiZcbiAgICAgIHBhcmVudCAmJlxuICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIlxuICAgICkge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIGJlZm9yZS5sZW5ndGgsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBwb3MgKyB0b2tlbi5sZW5ndGgsXG4gICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgfSk7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzbGFzaCB8fCBjb2RlID09PSBjb21tYSB8fCBjb2RlID09PSBjb2xvbikge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZGl2XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MgLSBiZWZvcmUubGVuZ3RoLFxuICAgICAgICBzb3VyY2VFbmRJbmRleDogcG9zICsgdG9rZW4ubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogXCJcIlxuICAgICAgfSk7XG4gICAgICBiZWZvcmUgPSBcIlwiO1xuXG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZW4gcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgLy8gV2hpdGVzcGFjZXMgYWZ0ZXIgb3BlbiBwYXJlbnRoZXNlc1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgcGFyZW50aGVzZXNPcGVuUG9zID0gcG9zO1xuICAgICAgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIG5hbWUubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgYmVmb3JlOiB2YWx1ZS5zbGljZShwYXJlbnRoZXNlc09wZW5Qb3MgKyAxLCBuZXh0KVxuICAgICAgfTtcbiAgICAgIHBvcyA9IG5leHQ7XG5cbiAgICAgIGlmIChuYW1lID09PSBcInVybFwiICYmIGNvZGUgIT09IHNpbmdsZVF1b3RlICYmIGNvZGUgIT09IGRvdWJsZVF1b3RlKSB7XG4gICAgICAgIG5leHQgLT0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IGJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCIpXCI7XG4gICAgICAgICAgICBuZXh0ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZSk7XG4gICAgICAgIC8vIFdoaXRlc3BhY2VzIGJlZm9yZSBjbG9zZWRcbiAgICAgICAgd2hpdGVzcGFjZVBvcyA9IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zIC09IDE7XG4gICAgICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQod2hpdGVzcGFjZVBvcyk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgICBpZiAocGFyZW50aGVzZXNPcGVuUG9zIDwgd2hpdGVzcGFjZVBvcykge1xuICAgICAgICAgIGlmIChwb3MgIT09IHdoaXRlc3BhY2VQb3MgKyAxKSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IHdoaXRlc3BhY2VQb3MgKyAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZShwb3MsIHdoaXRlc3BhY2VQb3MgKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4udW5jbG9zZWQgJiYgd2hpdGVzcGFjZVBvcyArIDEgIT09IG5leHQpIHtcbiAgICAgICAgICAgIHRva2VuLmFmdGVyID0gXCJcIjtcbiAgICAgICAgICAgIHRva2VuLm5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUluZGV4OiB3aGl0ZXNwYWNlUG9zICsgMSxcbiAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IG5leHQsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSh3aGl0ZXNwYWNlUG9zICsgMSwgbmV4dClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5hZnRlciA9IHZhbHVlLnNsaWNlKHdoaXRlc3BhY2VQb3MgKyAxLCBuZXh0KTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4uYWZ0ZXIgPSBcIlwiO1xuICAgICAgICAgIHRva2VuLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gdG9rZW4udW5jbG9zZWQgPyBuZXh0IDogcG9zO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWxhbmNlZCArPSAxO1xuICAgICAgICB0b2tlbi5hZnRlciA9IFwiXCI7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgcGFyZW50ID0gdG9rZW47XG4gICAgICB9XG4gICAgICBuYW1lID0gXCJcIjtcblxuICAgICAgLy8gQ2xvc2UgcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKGNsb3NlUGFyZW50aGVzZXMgPT09IGNvZGUgJiYgYmFsYW5jZWQpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgcGFyZW50LmFmdGVyID0gYWZ0ZXI7XG4gICAgICBwYXJlbnQuc291cmNlRW5kSW5kZXggKz0gYWZ0ZXIubGVuZ3RoO1xuICAgICAgYWZ0ZXIgPSBcIlwiO1xuICAgICAgYmFsYW5jZWQgLT0gMTtcbiAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnNvdXJjZUVuZEluZGV4ID0gcG9zO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJlbnQgPSBzdGFja1tiYWxhbmNlZF07XG4gICAgICB0b2tlbnMgPSBwYXJlbnQubm9kZXM7XG5cbiAgICAgIC8vIFdvcmRzXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb2RlID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBuZXh0IDwgbWF4ICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29kZSA8PSAzMiB8fFxuICAgICAgICAgIGNvZGUgPT09IHNpbmdsZVF1b3RlIHx8XG4gICAgICAgICAgY29kZSA9PT0gZG91YmxlUXVvdGUgfHxcbiAgICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICAgIGNvZGUgPT09IGNvbG9uIHx8XG4gICAgICAgICAgY29kZSA9PT0gc2xhc2ggfHxcbiAgICAgICAgICBjb2RlID09PSBvcGVuUGFyZW50aGVzZXMgfHxcbiAgICAgICAgICAoY29kZSA9PT0gc3RhciAmJlxuICAgICAgICAgICAgcGFyZW50ICYmXG4gICAgICAgICAgICBwYXJlbnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPT09IFwiY2FsY1wiKSB8fFxuICAgICAgICAgIChjb2RlID09PSBzbGFzaCAmJlxuICAgICAgICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIikgfHxcbiAgICAgICAgICAoY29kZSA9PT0gY2xvc2VQYXJlbnRoZXNlcyAmJiBiYWxhbmNlZClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRva2VuID0gdmFsdWUuc2xpY2UocG9zLCBuZXh0KTtcblxuICAgICAgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodUxvd2VyID09PSB0b2tlbi5jaGFyQ29kZUF0KDApIHx8IHVVcHBlciA9PT0gdG9rZW4uY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgcGx1cyA9PT0gdG9rZW4uY2hhckNvZGVBdCgxKSAmJlxuICAgICAgICBpc1VuaWNvZGVSYW5nZS50ZXN0KHRva2VuLnNsaWNlKDIpKVxuICAgICAgKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInVuaWNvZGUtcmFuZ2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvczsgcG9zIC09IDEpIHtcbiAgICBzdGFja1twb3NdLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICBzdGFja1twb3NdLnNvdXJjZUVuZEluZGV4ID0gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrWzBdLm5vZGVzO1xufTtcblxudmFyIHdhbGskMSA9IGZ1bmN0aW9uIHdhbGsobm9kZXMsIGNiLCBidWJibGUpIHtcbiAgdmFyIGksIG1heCwgbm9kZSwgcmVzdWx0O1xuXG4gIGZvciAoaSA9IDAsIG1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heDsgaSArPSAxKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghYnViYmxlKSB7XG4gICAgICByZXN1bHQgPSBjYihub2RlLCBpLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzdWx0ICE9PSBmYWxzZSAmJlxuICAgICAgbm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobm9kZS5ub2RlcylcbiAgICApIHtcbiAgICAgIHdhbGsobm9kZS5ub2RlcywgY2IsIGJ1YmJsZSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgY2Iobm9kZSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlLCBjdXN0b20pIHtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIHZhciBidWY7XG4gIHZhciBjdXN0b21SZXN1bHQ7XG5cbiAgaWYgKGN1c3RvbSAmJiAoY3VzdG9tUmVzdWx0ID0gY3VzdG9tKG5vZGUpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGN1c3RvbVJlc3VsdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIndvcmRcIiB8fCB0eXBlID09PSBcInNwYWNlXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJ1ZiA9IG5vZGUucXVvdGUgfHwgXCJcIjtcbiAgICByZXR1cm4gYnVmICsgdmFsdWUgKyAobm9kZS51bmNsb3NlZCA/IFwiXCIgOiBidWYpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgcmV0dXJuIFwiLypcIiArIHZhbHVlICsgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIqL1wiKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpdlwiKSB7XG4gICAgcmV0dXJuIChub2RlLmJlZm9yZSB8fCBcIlwiKSArIHZhbHVlICsgKG5vZGUuYWZ0ZXIgfHwgXCJcIik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlLm5vZGVzKSkge1xuICAgIGJ1ZiA9IHN0cmluZ2lmeSQxKG5vZGUubm9kZXMsIGN1c3RvbSk7XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICtcbiAgICAgIFwiKFwiICtcbiAgICAgIChub2RlLmJlZm9yZSB8fCBcIlwiKSArXG4gICAgICBidWYgK1xuICAgICAgKG5vZGUuYWZ0ZXIgfHwgXCJcIikgK1xuICAgICAgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIpXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSQxKG5vZGVzLCBjdXN0b20pIHtcbiAgdmFyIHJlc3VsdCwgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoaSA9IG5vZGVzLmxlbmd0aCAtIDE7IH5pOyBpIC09IDEpIHtcbiAgICAgIHJlc3VsdCA9IHN0cmluZ2lmeU5vZGUobm9kZXNbaV0sIGN1c3RvbSkgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeU5vZGUobm9kZXMsIGN1c3RvbSk7XG59XG5cbnZhciBzdHJpbmdpZnlfMSA9IHN0cmluZ2lmeSQxO1xuXG52YXIgdW5pdDtcbnZhciBoYXNSZXF1aXJlZFVuaXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVbml0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVW5pdCkgcmV0dXJuIHVuaXQ7XG5cdGhhc1JlcXVpcmVkVW5pdCA9IDE7XG5cdHZhciBtaW51cyA9IFwiLVwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBwbHVzID0gXCIrXCIuY2hhckNvZGVBdCgwKTtcblx0dmFyIGRvdCA9IFwiLlwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBleHAgPSBcImVcIi5jaGFyQ29kZUF0KDApO1xuXHR2YXIgRVhQID0gXCJFXCIuY2hhckNvZGVBdCgwKTtcblxuXHQvLyBDaGVjayBpZiB0aHJlZSBjb2RlIHBvaW50cyB3b3VsZCBzdGFydCBhIG51bWJlclxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNzdGFydHMtd2l0aC1hLW51bWJlclxuXHRmdW5jdGlvbiBsaWtlTnVtYmVyKHZhbHVlKSB7XG5cdCAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHQgIHZhciBuZXh0Q29kZTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5leHROZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMik7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA9PT0gZG90ICYmIG5leHROZXh0Q29kZSA+PSA0OCAmJiBuZXh0TmV4dENvZGUgPD0gNTcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoY29kZSA9PT0gZG90KSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIENvbnN1bWUgYSBudW1iZXJcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jY29uc3VtZS1udW1iZXJcblx0dW5pdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgdmFyIHBvcyA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0ICB2YXIgY29kZTtcblx0ICB2YXIgbmV4dENvZGU7XG5cdCAgdmFyIG5leHROZXh0Q29kZTtcblxuXHQgIGlmIChsZW5ndGggPT09IDAgfHwgIWxpa2VOdW1iZXIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBwb3MrKztcblx0ICB9XG5cblx0ICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgcG9zICs9IDE7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblx0ICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cblx0ICBpZiAoY29kZSA9PT0gZG90ICYmIG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB7XG5cdCAgICBwb3MgKz0gMjtcblxuXHQgICAgd2hpbGUgKHBvcyA8IGxlbmd0aCkge1xuXHQgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBwb3MgKz0gMTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXHQgIG5leHRDb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKTtcblx0ICBuZXh0TmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyArIDIpO1xuXG5cdCAgaWYgKFxuXHQgICAgKGNvZGUgPT09IGV4cCB8fCBjb2RlID09PSBFWFApICYmXG5cdCAgICAoKG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB8fFxuXHQgICAgICAoKG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cykgJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPj0gNDggJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPD0gNTcpKVxuXHQgICkge1xuXHQgICAgcG9zICs9IG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cyA/IDMgOiAyO1xuXG5cdCAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cblx0ICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIHBvcyArPSAxO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBudW1iZXI6IHZhbHVlLnNsaWNlKDAsIHBvcyksXG5cdCAgICB1bml0OiB2YWx1ZS5zbGljZShwb3MpXG5cdCAgfTtcblx0fTtcblx0cmV0dXJuIHVuaXQ7XG59XG5cbnZhciBwYXJzZSA9IHBhcnNlJDE7XG52YXIgd2FsayA9IHdhbGskMTtcbnZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnlfMTtcblxuZnVuY3Rpb24gVmFsdWVQYXJzZXIodmFsdWUpIHtcbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWYWx1ZVBhcnNlcikge1xuICAgIHRoaXMubm9kZXMgPSBwYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG5ldyBWYWx1ZVBhcnNlcih2YWx1ZSk7XG59XG5cblZhbHVlUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSA/IHN0cmluZ2lmeSh0aGlzLm5vZGVzKSA6IFwiXCI7XG59O1xuXG5WYWx1ZVBhcnNlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKGNiLCBidWJibGUpIHtcbiAgd2Fsayh0aGlzLm5vZGVzLCBjYiwgYnViYmxlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYWx1ZVBhcnNlci51bml0ID0gcmVxdWlyZVVuaXQoKTtcblxuVmFsdWVQYXJzZXIud2FsayA9IHdhbGs7XG5cblZhbHVlUGFyc2VyLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxudmFyIGxpYiA9IFZhbHVlUGFyc2VyO1xuXG5leHBvcnQgeyBsaWIgYXMgbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-07a79996.js\n");

/***/ }),

/***/ "./node_modules/vite/dist/node/chunks/dep-9deb2354.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-9deb2354.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"i\": () => (/* binding */ index)\n/* harmony export */ });\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resolve */ \"./node_modules/resolve/index.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _dep_07a79996_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dep-07a79996.js */ \"./node_modules/vite/dist/node/chunks/dep-07a79996.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:module */ \"node:module\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-9deb2354.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_4__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-9deb2354.js\");\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nvar joinMedia$1 = function (parentMedia, childMedia) {\n  if (!parentMedia.length && childMedia.length) return childMedia\n  if (parentMedia.length && !childMedia.length) return parentMedia\n  if (!parentMedia.length && !childMedia.length) return []\n\n  const media = [];\n\n  parentMedia.forEach(parentItem => {\n    childMedia.forEach(childItem => {\n      if (parentItem !== childItem) media.push(`${parentItem} and ${childItem}`);\n    });\n  });\n\n  return media\n};\n\nvar joinLayer$1 = function (parentLayer, childLayer) {\n  if (!parentLayer.length && childLayer.length) return childLayer\n  if (parentLayer.length && !childLayer.length) return parentLayer\n  if (!parentLayer.length && !childLayer.length) return []\n\n  return parentLayer.concat(childLayer)\n};\n\n// external tooling\nconst resolve$1 = resolve__WEBPACK_IMPORTED_MODULE_1__;\n\nconst moduleDirectories = [\"web_modules\", \"node_modules\"];\n\nfunction resolveModule(id, opts) {\n  return new Promise((res, rej) => {\n    resolve$1(id, opts, (err, path) => (err ? rej(err) : res(path)));\n  })\n}\n\nvar resolveId$1 = function (id, base, options) {\n  const paths = options.path;\n\n  const resolveOpts = {\n    basedir: base,\n    moduleDirectory: moduleDirectories.concat(options.addModulesDirectories),\n    paths,\n    extensions: [\".css\"],\n    packageFilter: function processPackage(pkg) {\n      if (pkg.style) pkg.main = pkg.style;\n      else if (!pkg.main || !/\\.css$/.test(pkg.main)) pkg.main = \"index.css\";\n      return pkg\n    },\n    preserveSymlinks: false,\n  };\n\n  return resolveModule(`./${id}`, resolveOpts)\n    .catch(() => resolveModule(id, resolveOpts))\n    .catch(() => {\n      if (paths.indexOf(base) === -1) paths.unshift(base);\n\n      throw new Error(\n        `Failed to find '${id}'\n  in [\n    ${paths.join(\",\\n        \")}\n  ]`\n      )\n    })\n};\n\nvar readCache$1 = {exports: {}};\n\nvar pify$2 = {exports: {}};\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify$1.all = pify$1;\n\nvar fs = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\r\nvar path$2 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\r\nvar pify = pify$2.exports;\r\n\r\nvar stat = pify(fs.stat);\r\nvar readFile = pify(fs.readFile);\r\nvar resolve = path$2.resolve;\r\n\r\nvar cache = Object.create(null);\r\n\r\nfunction convert(content, encoding) {\r\n\tif (Buffer.isEncoding(encoding)) {\r\n\t\treturn content.toString(encoding);\r\n\t}\r\n\treturn content;\r\n}\r\n\r\nreadCache$1.exports = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\treturn stat(path).then(function (stats) {\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\treturn readFile(path).then(function (data) {\r\n\t\t\tcache[path] = {\r\n\t\t\t\tmtime: stats.mtime,\r\n\t\t\t\tcontent: data\r\n\t\t\t};\r\n\r\n\t\t\treturn convert(data, encoding);\r\n\t\t});\r\n\t}).catch(function (err) {\r\n\t\tcache[path] = null;\r\n\t\treturn Promise.reject(err);\r\n\t});\r\n};\r\n\r\nreadCache$1.exports.sync = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\ttry {\r\n\t\tvar stats = fs.statSync(path);\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\tvar data = fs.readFileSync(path);\r\n\r\n\t\tcache[path] = {\r\n\t\t\tmtime: stats.mtime,\r\n\t\t\tcontent: data\r\n\t\t};\r\n\r\n\t\treturn convert(data, encoding);\r\n\t} catch (err) {\r\n\t\tcache[path] = null;\r\n\t\tthrow err;\r\n\t}\r\n\r\n};\r\n\r\nreadCache$1.exports.get = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\tif (cache[path]) {\r\n\t\treturn convert(cache[path].content, encoding);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nreadCache$1.exports.clear = function () {\r\n\tcache = Object.create(null);\r\n};\n\nconst readCache = readCache$1.exports;\n\nvar loadContent$1 = filename => readCache(filename, \"utf-8\");\n\n// builtin tooling\nconst path$1 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n// placeholder tooling\nlet sugarss;\n\nvar processContent$1 = function processContent(\n  result,\n  content,\n  filename,\n  options,\n  postcss\n) {\n  const { plugins } = options;\n  const ext = path$1.extname(filename);\n\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss)\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n\n  return runPostcss(postcss, content, filename, plugins, parserList)\n};\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins)\n    .process(content, {\n      from: filename,\n      parser: parsers[index],\n    })\n    .catch(err => {\n      // If there's an error, try the next parser\n      index++;\n      // If there are no parsers left, throw it\n      if (index === parsers.length) throw err\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\n    })\n}\n\n// external tooling\nconst valueParser = _dep_07a79996_js__WEBPACK_IMPORTED_MODULE_2__.l;\n\n// extended tooling\nconst { stringify } = valueParser;\n\nfunction split(params, start) {\n  const list = [];\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\");\n  list.push(last);\n  return list\n}\n\nvar parseStatements$1 = function (result, styles) {\n  const statements = [];\n  let nodes = [];\n\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);\n      else if (node.name === \"media\") stmt = parseMedia(result, node);\n      else if (node.name === \"charset\") stmt = parseCharset(result, node);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: [],\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: [],\n    });\n  }\n\n  return statements\n};\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: [],\n  }\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev();\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"comment\" &&\n        (prev.type !== \"atrule\" ||\n          (prev.name !== \"import\" &&\n            prev.name !== \"charset\" &&\n            !(prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset or empty @layer)\",\n          { node: atRule }\n        )\n      }\n      prev = prev.prev();\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: [],\n  };\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value;\n  else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n\n  let remainder = params;\n  if (remainder.length > 2) {\n    if (\n      (remainder[2].type === \"word\" || remainder[2].type === \"function\") &&\n      remainder[2].value === \"layer\"\n    ) {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", { node: atRule })\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)];\n      } else {\n        stmt.layer = [\"\"];\n      }\n      remainder = remainder.slice(2);\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n\n    stmt.media = split(remainder, 2);\n  }\n\n  return stmt\n}\n\n// builtin tooling\nconst path = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n// internal tooling\nconst joinMedia = joinMedia$1;\nconst joinLayer = joinLayer$1;\nconst resolveId = resolveId$1;\nconst loadContent = loadContent$1;\nconst processContent = processContent$1;\nconst parseStatements = parseStatements$1;\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options,\n  };\n\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n\n  if (!Array.isArray(options.path)) options.path = [];\n\n  options.path = options.path.map(p => path.resolve(options.root, p));\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0,\n      };\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file;\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle);\n          applyMedia(bundle);\n          applyStyles(bundle, styles);\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;\n            else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.type === \"import\") {\n            stmt.node.params = `${stmt.fullUri} ${stmt.media.join(\", \")}`;\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: stmt.node.source,\n              });\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source,\n                });\n\n                mediaNode.append(layerNode);\n                layerNode.append(stmt.node);\n                stmt.node = mediaNode;\n              } else {\n                layerNode.append(stmt.node);\n                stmt.node = layerNode;\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \");\n            }\n          } else {\n            const { nodes } = stmt;\n            const { parent } = nodes[0];\n\n            let outerAtRule;\n            let innerAtRule;\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              });\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source,\n              });\n\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              });\n\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source,\n              });\n\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule);\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined;\n            });\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes);\n\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = [];\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || []);\n                stmt.parentMedia = media;\n                stmt.layer = joinLayer(layer, stmt.layer || []);\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset;\n            const imports = [];\n            const bundle = [];\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt;\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt);\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child);\n                    else if (child.type === \"charset\") handleCharset(child);\n                    else bundle.push(child);\n                    // For better output\n                    if (index === 0) child.parent = stmt;\n                  });\n                } else imports.push(stmt);\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt);\n              }\n            });\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        const atRule = stmt.node;\n        let sourceFile;\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file;\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root;\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths];\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file, base, options)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              });\n            });\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, []);\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const { media, layer } = stmt;\n        layer.forEach((layerPart, i) => {\n          if (layerPart === \"\") {\n            if (options.nameLayer) {\n              layer[i] = options\n                .nameLayer(state.anonymousLayerCounter++, state.rootFilename)\n                .toString();\n            } else {\n              throw atRule.error(\n                `When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`\n              )\n            }\n          }\n        });\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {};\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {};\n          }\n          state.importedFiles[filename][media][layer] = true;\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule });\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content]?.[media]?.[layer]) {\n              return\n            }\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root;\n              result.messages = result.messages.concat(importedResult.messages);\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                });\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) {\n                    state.hashFiles[content] = {};\n                  }\n                  if (!state.hashFiles[content][media]) {\n                    state.hashFiles[content][media] = {};\n                  }\n                  state.hashFiles[content][media][layer] = true;\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true;\n\nvar postcssImport = AtImport;\n\nvar index = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  'default': postcssImport\n}, [postcssImport]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC05ZGViMjM1NC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQThCO0FBQ0U7QUFDSztBQUNROztBQUVtQjtBQUNYO0FBQ2M7O0FBRW5FLG1CQUFtQix1REFBbUIsQ0FBQyw2RkFBZTtBQUN0RCxrQkFBa0Isa0RBQWE7QUFDL0IsZ0JBQWdCLDBEQUFtQixDQUFDLDZGQUFlO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVksTUFBTSxVQUFVO0FBQzlFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQ0FBUzs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsNEJBQTRCLEdBQUc7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxtQkFBbUI7O0FBRW5CLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSxhQUFhLGNBQWM7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVxQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92aXRlL2Rpc3Qvbm9kZS9jaHVua3MvZGVwLTlkZWIyMzU0LmpzPzQ5ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSAncGF0aCc7XG5pbXBvcnQgcmVzb2x2ZSQyIGZyb20gJ3Jlc29sdmUnO1xuaW1wb3J0IHJlcXVpcmUkJDBfX2RlZmF1bHQgZnJvbSAnZnMnO1xuaW1wb3J0IHsgbCBhcyBsaWIgfSBmcm9tICcuL2RlcC0wN2E3OTk5Ni5qcyc7XG5cbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBtW2ldO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkpIHsgZm9yICh2YXIgayBpbiBlKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuICAgICAgICBuW2tdID0gZVtrXTtcbiAgICAgIH1cbiAgICB9IH1cbiAgfVxuICByZXR1cm4gbjtcbn1cblxudmFyIGpvaW5NZWRpYSQxID0gZnVuY3Rpb24gKHBhcmVudE1lZGlhLCBjaGlsZE1lZGlhKSB7XG4gIGlmICghcGFyZW50TWVkaWEubGVuZ3RoICYmIGNoaWxkTWVkaWEubGVuZ3RoKSByZXR1cm4gY2hpbGRNZWRpYVxuICBpZiAocGFyZW50TWVkaWEubGVuZ3RoICYmICFjaGlsZE1lZGlhLmxlbmd0aCkgcmV0dXJuIHBhcmVudE1lZGlhXG4gIGlmICghcGFyZW50TWVkaWEubGVuZ3RoICYmICFjaGlsZE1lZGlhLmxlbmd0aCkgcmV0dXJuIFtdXG5cbiAgY29uc3QgbWVkaWEgPSBbXTtcblxuICBwYXJlbnRNZWRpYS5mb3JFYWNoKHBhcmVudEl0ZW0gPT4ge1xuICAgIGNoaWxkTWVkaWEuZm9yRWFjaChjaGlsZEl0ZW0gPT4ge1xuICAgICAgaWYgKHBhcmVudEl0ZW0gIT09IGNoaWxkSXRlbSkgbWVkaWEucHVzaChgJHtwYXJlbnRJdGVtfSBhbmQgJHtjaGlsZEl0ZW19YCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBtZWRpYVxufTtcblxudmFyIGpvaW5MYXllciQxID0gZnVuY3Rpb24gKHBhcmVudExheWVyLCBjaGlsZExheWVyKSB7XG4gIGlmICghcGFyZW50TGF5ZXIubGVuZ3RoICYmIGNoaWxkTGF5ZXIubGVuZ3RoKSByZXR1cm4gY2hpbGRMYXllclxuICBpZiAocGFyZW50TGF5ZXIubGVuZ3RoICYmICFjaGlsZExheWVyLmxlbmd0aCkgcmV0dXJuIHBhcmVudExheWVyXG4gIGlmICghcGFyZW50TGF5ZXIubGVuZ3RoICYmICFjaGlsZExheWVyLmxlbmd0aCkgcmV0dXJuIFtdXG5cbiAgcmV0dXJuIHBhcmVudExheWVyLmNvbmNhdChjaGlsZExheWVyKVxufTtcblxuLy8gZXh0ZXJuYWwgdG9vbGluZ1xuY29uc3QgcmVzb2x2ZSQxID0gcmVzb2x2ZSQyO1xuXG5jb25zdCBtb2R1bGVEaXJlY3RvcmllcyA9IFtcIndlYl9tb2R1bGVzXCIsIFwibm9kZV9tb2R1bGVzXCJdO1xuXG5mdW5jdGlvbiByZXNvbHZlTW9kdWxlKGlkLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlJDEoaWQsIG9wdHMsIChlcnIsIHBhdGgpID0+IChlcnIgPyByZWooZXJyKSA6IHJlcyhwYXRoKSkpO1xuICB9KVxufVxuXG52YXIgcmVzb2x2ZUlkJDEgPSBmdW5jdGlvbiAoaWQsIGJhc2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGF0aHMgPSBvcHRpb25zLnBhdGg7XG5cbiAgY29uc3QgcmVzb2x2ZU9wdHMgPSB7XG4gICAgYmFzZWRpcjogYmFzZSxcbiAgICBtb2R1bGVEaXJlY3Rvcnk6IG1vZHVsZURpcmVjdG9yaWVzLmNvbmNhdChvcHRpb25zLmFkZE1vZHVsZXNEaXJlY3RvcmllcyksXG4gICAgcGF0aHMsXG4gICAgZXh0ZW5zaW9uczogW1wiLmNzc1wiXSxcbiAgICBwYWNrYWdlRmlsdGVyOiBmdW5jdGlvbiBwcm9jZXNzUGFja2FnZShwa2cpIHtcbiAgICAgIGlmIChwa2cuc3R5bGUpIHBrZy5tYWluID0gcGtnLnN0eWxlO1xuICAgICAgZWxzZSBpZiAoIXBrZy5tYWluIHx8ICEvXFwuY3NzJC8udGVzdChwa2cubWFpbikpIHBrZy5tYWluID0gXCJpbmRleC5jc3NcIjtcbiAgICAgIHJldHVybiBwa2dcbiAgICB9LFxuICAgIHByZXNlcnZlU3ltbGlua3M6IGZhbHNlLFxuICB9O1xuXG4gIHJldHVybiByZXNvbHZlTW9kdWxlKGAuLyR7aWR9YCwgcmVzb2x2ZU9wdHMpXG4gICAgLmNhdGNoKCgpID0+IHJlc29sdmVNb2R1bGUoaWQsIHJlc29sdmVPcHRzKSlcbiAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgaWYgKHBhdGhzLmluZGV4T2YoYmFzZSkgPT09IC0xKSBwYXRocy51bnNoaWZ0KGJhc2UpO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmluZCAnJHtpZH0nXG4gIGluIFtcbiAgICAke3BhdGhzLmpvaW4oXCIsXFxuICAgICAgICBcIil9XG4gIF1gXG4gICAgICApXG4gICAgfSlcbn07XG5cbnZhciByZWFkQ2FjaGUkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBwaWZ5JDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcHJvY2Vzc0ZuID0gZnVuY3Rpb24gKGZuLCBQLCBvcHRzKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm4uYXBwbHkodGhhdCwgYXJncyk7XG5cdFx0fSk7XG5cdH07XG59O1xuXG52YXIgcGlmeSQxID0gcGlmeSQyLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBQLCBvcHRzKSB7XG5cdGlmICh0eXBlb2YgUCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdG9wdHMgPSBQO1xuXHRcdFAgPSBQcm9taXNlO1xuXHR9XG5cblx0b3B0cyA9IG9wdHMgfHwge307XG5cdG9wdHMuZXhjbHVkZSA9IG9wdHMuZXhjbHVkZSB8fCBbLy4rU3luYyQvXTtcblxuXHR2YXIgZmlsdGVyID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBtYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBvcHRzLmluY2x1ZGUgPyBvcHRzLmluY2x1ZGUuc29tZShtYXRjaCkgOiAhb3B0cy5leGNsdWRlLnNvbWUobWF0Y2gpO1xuXHR9O1xuXG5cdHZhciByZXQgPSB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIFAsIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0gOiB7fTtcblxuXHRyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwga2V5KSB7XG5cdFx0dmFyIHggPSBvYmpba2V5XTtcblxuXHRcdHJldFtrZXldID0gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGtleSkgPyBwcm9jZXNzRm4oeCwgUCwgb3B0cykgOiB4O1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwgcmV0KTtcbn07XG5cbnBpZnkkMS5hbGwgPSBwaWZ5JDE7XG5cbnZhciBmcyA9IHJlcXVpcmUkJDBfX2RlZmF1bHQ7XHJcbnZhciBwYXRoJDIgPSByZXF1aXJlJCQwO1xyXG52YXIgcGlmeSA9IHBpZnkkMi5leHBvcnRzO1xyXG5cclxudmFyIHN0YXQgPSBwaWZ5KGZzLnN0YXQpO1xyXG52YXIgcmVhZEZpbGUgPSBwaWZ5KGZzLnJlYWRGaWxlKTtcclxudmFyIHJlc29sdmUgPSBwYXRoJDIucmVzb2x2ZTtcclxuXHJcbnZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0KGNvbnRlbnQsIGVuY29kaW5nKSB7XHJcblx0aWYgKEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xyXG5cdFx0cmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoZW5jb2RpbmcpO1xyXG5cdH1cclxuXHRyZXR1cm4gY29udGVudDtcclxufVxyXG5cclxucmVhZENhY2hlJDEuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXRoLCBlbmNvZGluZykge1xyXG5cdHBhdGggPSByZXNvbHZlKHBhdGgpO1xyXG5cclxuXHRyZXR1cm4gc3RhdChwYXRoKS50aGVuKGZ1bmN0aW9uIChzdGF0cykge1xyXG5cdFx0dmFyIGl0ZW0gPSBjYWNoZVtwYXRoXTtcclxuXHJcblx0XHRpZiAoaXRlbSAmJiBpdGVtLm10aW1lLmdldFRpbWUoKSA9PT0gc3RhdHMubXRpbWUuZ2V0VGltZSgpKSB7XHJcblx0XHRcdHJldHVybiBjb252ZXJ0KGl0ZW0uY29udGVudCwgZW5jb2RpbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWFkRmlsZShwYXRoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHRcdGNhY2hlW3BhdGhdID0ge1xyXG5cdFx0XHRcdG10aW1lOiBzdGF0cy5tdGltZSxcclxuXHRcdFx0XHRjb250ZW50OiBkYXRhXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gY29udmVydChkYXRhLCBlbmNvZGluZyk7XHJcblx0XHR9KTtcclxuXHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcblx0XHRjYWNoZVtwYXRoXSA9IG51bGw7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuXHR9KTtcclxufTtcclxuXHJcbnJlYWRDYWNoZSQxLmV4cG9ydHMuc3luYyA9IGZ1bmN0aW9uIChwYXRoLCBlbmNvZGluZykge1xyXG5cdHBhdGggPSByZXNvbHZlKHBhdGgpO1xyXG5cclxuXHR0cnkge1xyXG5cdFx0dmFyIHN0YXRzID0gZnMuc3RhdFN5bmMocGF0aCk7XHJcblx0XHR2YXIgaXRlbSA9IGNhY2hlW3BhdGhdO1xyXG5cclxuXHRcdGlmIChpdGVtICYmIGl0ZW0ubXRpbWUuZ2V0VGltZSgpID09PSBzdGF0cy5tdGltZS5nZXRUaW1lKCkpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnZlcnQoaXRlbS5jb250ZW50LCBlbmNvZGluZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XHJcblxyXG5cdFx0Y2FjaGVbcGF0aF0gPSB7XHJcblx0XHRcdG10aW1lOiBzdGF0cy5tdGltZSxcclxuXHRcdFx0Y29udGVudDogZGF0YVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gY29udmVydChkYXRhLCBlbmNvZGluZyk7XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRjYWNoZVtwYXRoXSA9IG51bGw7XHJcblx0XHR0aHJvdyBlcnI7XHJcblx0fVxyXG5cclxufTtcclxuXHJcbnJlYWRDYWNoZSQxLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKHBhdGgsIGVuY29kaW5nKSB7XHJcblx0cGF0aCA9IHJlc29sdmUocGF0aCk7XHJcblx0aWYgKGNhY2hlW3BhdGhdKSB7XHJcblx0XHRyZXR1cm4gY29udmVydChjYWNoZVtwYXRoXS5jb250ZW50LCBlbmNvZGluZyk7XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxucmVhZENhY2hlJDEuZXhwb3J0cy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHRjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbn07XG5cbmNvbnN0IHJlYWRDYWNoZSA9IHJlYWRDYWNoZSQxLmV4cG9ydHM7XG5cbnZhciBsb2FkQ29udGVudCQxID0gZmlsZW5hbWUgPT4gcmVhZENhY2hlKGZpbGVuYW1lLCBcInV0Zi04XCIpO1xuXG4vLyBidWlsdGluIHRvb2xpbmdcbmNvbnN0IHBhdGgkMSA9IHJlcXVpcmUkJDA7XG5cbi8vIHBsYWNlaG9sZGVyIHRvb2xpbmdcbmxldCBzdWdhcnNzO1xuXG52YXIgcHJvY2Vzc0NvbnRlbnQkMSA9IGZ1bmN0aW9uIHByb2Nlc3NDb250ZW50KFxuICByZXN1bHQsXG4gIGNvbnRlbnQsXG4gIGZpbGVuYW1lLFxuICBvcHRpb25zLFxuICBwb3N0Y3NzXG4pIHtcbiAgY29uc3QgeyBwbHVnaW5zIH0gPSBvcHRpb25zO1xuICBjb25zdCBleHQgPSBwYXRoJDEuZXh0bmFtZShmaWxlbmFtZSk7XG5cbiAgY29uc3QgcGFyc2VyTGlzdCA9IFtdO1xuXG4gIC8vIFN1Z2FyU1Mgc3VwcG9ydDpcbiAgaWYgKGV4dCA9PT0gXCIuc3NzXCIpIHtcbiAgICBpZiAoIXN1Z2Fyc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1Z2Fyc3MgPSBfX3JlcXVpcmUoJ3N1Z2Fyc3MnKTtcbiAgICAgIH0gY2F0Y2gge30gLy8gSWdub3JlXG4gICAgfVxuICAgIGlmIChzdWdhcnNzKVxuICAgICAgcmV0dXJuIHJ1blBvc3Rjc3MocG9zdGNzcywgY29udGVudCwgZmlsZW5hbWUsIHBsdWdpbnMsIFtzdWdhcnNzXSlcbiAgfVxuXG4gIC8vIFN5bnRheCBzdXBwb3J0OlxuICBpZiAocmVzdWx0Lm9wdHMuc3ludGF4Py5wYXJzZSkge1xuICAgIHBhcnNlckxpc3QucHVzaChyZXN1bHQub3B0cy5zeW50YXgucGFyc2UpO1xuICB9XG5cbiAgLy8gUGFyc2VyIHN1cHBvcnQ6XG4gIGlmIChyZXN1bHQub3B0cy5wYXJzZXIpIHBhcnNlckxpc3QucHVzaChyZXN1bHQub3B0cy5wYXJzZXIpO1xuICAvLyBUcnkgdGhlIGRlZmF1bHQgYXMgYSBsYXN0IHJlc29ydDpcbiAgcGFyc2VyTGlzdC5wdXNoKG51bGwpO1xuXG4gIHJldHVybiBydW5Qb3N0Y3NzKHBvc3Rjc3MsIGNvbnRlbnQsIGZpbGVuYW1lLCBwbHVnaW5zLCBwYXJzZXJMaXN0KVxufTtcblxuZnVuY3Rpb24gcnVuUG9zdGNzcyhwb3N0Y3NzLCBjb250ZW50LCBmaWxlbmFtZSwgcGx1Z2lucywgcGFyc2VycywgaW5kZXgpIHtcbiAgaWYgKCFpbmRleCkgaW5kZXggPSAwO1xuICByZXR1cm4gcG9zdGNzcyhwbHVnaW5zKVxuICAgIC5wcm9jZXNzKGNvbnRlbnQsIHtcbiAgICAgIGZyb206IGZpbGVuYW1lLFxuICAgICAgcGFyc2VyOiBwYXJzZXJzW2luZGV4XSxcbiAgICB9KVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciwgdHJ5IHRoZSBuZXh0IHBhcnNlclxuICAgICAgaW5kZXgrKztcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXJzZXJzIGxlZnQsIHRocm93IGl0XG4gICAgICBpZiAoaW5kZXggPT09IHBhcnNlcnMubGVuZ3RoKSB0aHJvdyBlcnJcbiAgICAgIHJldHVybiBydW5Qb3N0Y3NzKHBvc3Rjc3MsIGNvbnRlbnQsIGZpbGVuYW1lLCBwbHVnaW5zLCBwYXJzZXJzLCBpbmRleClcbiAgICB9KVxufVxuXG4vLyBleHRlcm5hbCB0b29saW5nXG5jb25zdCB2YWx1ZVBhcnNlciA9IGxpYjtcblxuLy8gZXh0ZW5kZWQgdG9vbGluZ1xuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHZhbHVlUGFyc2VyO1xuXG5mdW5jdGlvbiBzcGxpdChwYXJhbXMsIHN0YXJ0KSB7XG4gIGNvbnN0IGxpc3QgPSBbXTtcbiAgY29uc3QgbGFzdCA9IHBhcmFtcy5yZWR1Y2UoKGl0ZW0sIG5vZGUsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4IDwgc3RhcnQpIHJldHVybiBcIlwiXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJkaXZcIiAmJiBub2RlLnZhbHVlID09PSBcIixcIikge1xuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0gKyBzdHJpbmdpZnkobm9kZSlcbiAgfSwgXCJcIik7XG4gIGxpc3QucHVzaChsYXN0KTtcbiAgcmV0dXJuIGxpc3Rcbn1cblxudmFyIHBhcnNlU3RhdGVtZW50cyQxID0gZnVuY3Rpb24gKHJlc3VsdCwgc3R5bGVzKSB7XG4gIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcbiAgbGV0IG5vZGVzID0gW107XG5cbiAgc3R5bGVzLmVhY2gobm9kZSA9PiB7XG4gICAgbGV0IHN0bXQ7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbXBvcnRcIikgc3RtdCA9IHBhcnNlSW1wb3J0KHJlc3VsdCwgbm9kZSk7XG4gICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT09IFwibWVkaWFcIikgc3RtdCA9IHBhcnNlTWVkaWEocmVzdWx0LCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJjaGFyc2V0XCIpIHN0bXQgPSBwYXJzZUNoYXJzZXQocmVzdWx0LCBub2RlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RtdCkge1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwibm9kZXNcIixcbiAgICAgICAgICBub2RlcyxcbiAgICAgICAgICBtZWRpYTogW10sXG4gICAgICAgICAgbGF5ZXI6IFtdLFxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHN0YXRlbWVudHMucHVzaChzdG10KTtcbiAgICB9IGVsc2Ugbm9kZXMucHVzaChub2RlKTtcbiAgfSk7XG5cbiAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgIHN0YXRlbWVudHMucHVzaCh7XG4gICAgICB0eXBlOiBcIm5vZGVzXCIsXG4gICAgICBub2RlcyxcbiAgICAgIG1lZGlhOiBbXSxcbiAgICAgIGxheWVyOiBbXSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRzXG59O1xuXG5mdW5jdGlvbiBwYXJzZU1lZGlhKHJlc3VsdCwgYXRSdWxlKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbHVlUGFyc2VyKGF0UnVsZS5wYXJhbXMpLm5vZGVzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWVkaWFcIixcbiAgICBub2RlOiBhdFJ1bGUsXG4gICAgbWVkaWE6IHNwbGl0KHBhcmFtcywgMCksXG4gICAgbGF5ZXI6IFtdLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ2hhcnNldChyZXN1bHQsIGF0UnVsZSkge1xuICBpZiAoYXRSdWxlLnByZXYoKSkge1xuICAgIHJldHVybiByZXN1bHQud2FybihcIkBjaGFyc2V0IG11c3QgcHJlY2VkZSBhbGwgb3RoZXIgc3RhdGVtZW50c1wiLCB7XG4gICAgICBub2RlOiBhdFJ1bGUsXG4gICAgfSlcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY2hhcnNldFwiLFxuICAgIG5vZGU6IGF0UnVsZSxcbiAgICBtZWRpYTogW10sXG4gICAgbGF5ZXI6IFtdLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW1wb3J0KHJlc3VsdCwgYXRSdWxlKSB7XG4gIGxldCBwcmV2ID0gYXRSdWxlLnByZXYoKTtcbiAgaWYgKHByZXYpIHtcbiAgICBkbyB7XG4gICAgICBpZiAoXG4gICAgICAgIHByZXYudHlwZSAhPT0gXCJjb21tZW50XCIgJiZcbiAgICAgICAgKHByZXYudHlwZSAhPT0gXCJhdHJ1bGVcIiB8fFxuICAgICAgICAgIChwcmV2Lm5hbWUgIT09IFwiaW1wb3J0XCIgJiZcbiAgICAgICAgICAgIHByZXYubmFtZSAhPT0gXCJjaGFyc2V0XCIgJiZcbiAgICAgICAgICAgICEocHJldi5uYW1lID09PSBcImxheWVyXCIgJiYgIXByZXYubm9kZXMpKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lndhcm4oXG4gICAgICAgICAgXCJAaW1wb3J0IG11c3QgcHJlY2VkZSBhbGwgb3RoZXIgc3RhdGVtZW50cyAoYmVzaWRlcyBAY2hhcnNldCBvciBlbXB0eSBAbGF5ZXIpXCIsXG4gICAgICAgICAgeyBub2RlOiBhdFJ1bGUgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBwcmV2ID0gcHJldi5wcmV2KCk7XG4gICAgfSB3aGlsZSAocHJldilcbiAgfVxuXG4gIGlmIChhdFJ1bGUubm9kZXMpIHtcbiAgICByZXR1cm4gcmVzdWx0Lndhcm4oXG4gICAgICBcIkl0IGxvb2tzIGxpa2UgeW91IGRpZG4ndCBlbmQgeW91ciBAaW1wb3J0IHN0YXRlbWVudCBjb3JyZWN0bHkuIFwiICtcbiAgICAgICAgXCJDaGlsZCBub2RlcyBhcmUgYXR0YWNoZWQgdG8gaXQuXCIsXG4gICAgICB7IG5vZGU6IGF0UnVsZSB9XG4gICAgKVxuICB9XG5cbiAgY29uc3QgcGFyYW1zID0gdmFsdWVQYXJzZXIoYXRSdWxlLnBhcmFtcykubm9kZXM7XG4gIGNvbnN0IHN0bXQgPSB7XG4gICAgdHlwZTogXCJpbXBvcnRcIixcbiAgICBub2RlOiBhdFJ1bGUsXG4gICAgbWVkaWE6IFtdLFxuICAgIGxheWVyOiBbXSxcbiAgfTtcblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaWYgKFxuICAgICFwYXJhbXMubGVuZ3RoIHx8XG4gICAgKFxuICAgICAgcGFyYW1zWzBdLnR5cGUgIT09IFwic3RyaW5nXCIgfHxcbiAgICAgICFwYXJhbXNbMF0udmFsdWVcbiAgICApICYmXG4gICAgKFxuICAgICAgcGFyYW1zWzBdLnR5cGUgIT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgcGFyYW1zWzBdLnZhbHVlICE9PSBcInVybFwiIHx8XG4gICAgICAhcGFyYW1zWzBdLm5vZGVzLmxlbmd0aCB8fFxuICAgICAgIXBhcmFtc1swXS5ub2Rlc1swXS52YWx1ZVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHJlc3VsdC53YXJuKGBVbmFibGUgdG8gZmluZCB1cmkgaW4gJyR7ICBhdFJ1bGUudG9TdHJpbmcoKSAgfSdgLCB7XG4gICAgICBub2RlOiBhdFJ1bGUsXG4gICAgfSlcbiAgfVxuXG4gIGlmIChwYXJhbXNbMF0udHlwZSA9PT0gXCJzdHJpbmdcIikgc3RtdC51cmkgPSBwYXJhbXNbMF0udmFsdWU7XG4gIGVsc2Ugc3RtdC51cmkgPSBwYXJhbXNbMF0ubm9kZXNbMF0udmFsdWU7XG4gIHN0bXQuZnVsbFVyaSA9IHN0cmluZ2lmeShwYXJhbXNbMF0pO1xuXG4gIGxldCByZW1haW5kZXIgPSBwYXJhbXM7XG4gIGlmIChyZW1haW5kZXIubGVuZ3RoID4gMikge1xuICAgIGlmIChcbiAgICAgIChyZW1haW5kZXJbMl0udHlwZSA9PT0gXCJ3b3JkXCIgfHwgcmVtYWluZGVyWzJdLnR5cGUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgIHJlbWFpbmRlclsyXS52YWx1ZSA9PT0gXCJsYXllclwiXG4gICAgKSB7XG4gICAgICBpZiAocmVtYWluZGVyWzFdLnR5cGUgIT09IFwic3BhY2VcIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lndhcm4oXCJJbnZhbGlkIGltcG9ydCBsYXllciBzdGF0ZW1lbnRcIiwgeyBub2RlOiBhdFJ1bGUgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmRlclsyXS5ub2Rlcykge1xuICAgICAgICBzdG10LmxheWVyID0gW3N0cmluZ2lmeShyZW1haW5kZXJbMl0ubm9kZXMpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0bXQubGF5ZXIgPSBbXCJcIl07XG4gICAgICB9XG4gICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuc2xpY2UoMik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbWFpbmRlci5sZW5ndGggPiAyKSB7XG4gICAgaWYgKHJlbWFpbmRlclsxXS50eXBlICE9PSBcInNwYWNlXCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQud2FybihcIkludmFsaWQgaW1wb3J0IG1lZGlhIHN0YXRlbWVudFwiLCB7IG5vZGU6IGF0UnVsZSB9KVxuICAgIH1cblxuICAgIHN0bXQubWVkaWEgPSBzcGxpdChyZW1haW5kZXIsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHN0bXRcbn1cblxuLy8gYnVpbHRpbiB0b29saW5nXG5jb25zdCBwYXRoID0gcmVxdWlyZSQkMDtcblxuLy8gaW50ZXJuYWwgdG9vbGluZ1xuY29uc3Qgam9pbk1lZGlhID0gam9pbk1lZGlhJDE7XG5jb25zdCBqb2luTGF5ZXIgPSBqb2luTGF5ZXIkMTtcbmNvbnN0IHJlc29sdmVJZCA9IHJlc29sdmVJZCQxO1xuY29uc3QgbG9hZENvbnRlbnQgPSBsb2FkQ29udGVudCQxO1xuY29uc3QgcHJvY2Vzc0NvbnRlbnQgPSBwcm9jZXNzQ29udGVudCQxO1xuY29uc3QgcGFyc2VTdGF0ZW1lbnRzID0gcGFyc2VTdGF0ZW1lbnRzJDE7XG5cbmZ1bmN0aW9uIEF0SW1wb3J0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHtcbiAgICByb290OiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhdGg6IFtdLFxuICAgIHNraXBEdXBsaWNhdGVzOiB0cnVlLFxuICAgIHJlc29sdmU6IHJlc29sdmVJZCxcbiAgICBsb2FkOiBsb2FkQ29udGVudCxcbiAgICBwbHVnaW5zOiBbXSxcbiAgICBhZGRNb2R1bGVzRGlyZWN0b3JpZXM6IFtdLFxuICAgIG5hbWVMYXllcjogbnVsbCxcbiAgICAuLi5vcHRpb25zLFxuICB9O1xuXG4gIG9wdGlvbnMucm9vdCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLnJvb3QpO1xuXG4gIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGEgc2luZ2xlIGVsZW1lbnRcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnBhdGggPT09IFwic3RyaW5nXCIpIG9wdGlvbnMucGF0aCA9IFtvcHRpb25zLnBhdGhdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSBvcHRpb25zLnBhdGggPSBbXTtcblxuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnBhdGgubWFwKHAgPT4gcGF0aC5yZXNvbHZlKG9wdGlvbnMucm9vdCwgcCkpO1xuXG4gIHJldHVybiB7XG4gICAgcG9zdGNzc1BsdWdpbjogXCJwb3N0Y3NzLWltcG9ydFwiLFxuICAgIE9uY2Uoc3R5bGVzLCB7IHJlc3VsdCwgYXRSdWxlLCBwb3N0Y3NzIH0pIHtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBpbXBvcnRlZEZpbGVzOiB7fSxcbiAgICAgICAgaGFzaEZpbGVzOiB7fSxcbiAgICAgICAgcm9vdEZpbGVuYW1lOiBudWxsLFxuICAgICAgICBhbm9ueW1vdXNMYXllckNvdW50ZXI6IDAsXG4gICAgICB9O1xuXG4gICAgICBpZiAoc3R5bGVzLnNvdXJjZT8uaW5wdXQ/LmZpbGUpIHtcbiAgICAgICAgc3RhdGUucm9vdEZpbGVuYW1lID0gc3R5bGVzLnNvdXJjZS5pbnB1dC5maWxlO1xuICAgICAgICBzdGF0ZS5pbXBvcnRlZEZpbGVzW3N0eWxlcy5zb3VyY2UuaW5wdXQuZmlsZV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucGx1Z2lucyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBsdWdpbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsdWdpbnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXlcIilcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubmFtZUxheWVyICYmIHR5cGVvZiBvcHRpb25zLm5hbWVMYXllciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWVMYXllciBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZVN0eWxlcyhyZXN1bHQsIHN0eWxlcywgb3B0aW9ucywgc3RhdGUsIFtdLCBbXSkudGhlbihcbiAgICAgICAgYnVuZGxlID0+IHtcbiAgICAgICAgICBhcHBseVJhd3MoYnVuZGxlKTtcbiAgICAgICAgICBhcHBseU1lZGlhKGJ1bmRsZSk7XG4gICAgICAgICAgYXBwbHlTdHlsZXMoYnVuZGxlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5UmF3cyhidW5kbGUpIHtcbiAgICAgICAgYnVuZGxlLmZvckVhY2goKHN0bXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSByZXR1cm5cblxuICAgICAgICAgIGlmIChzdG10LnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBiZWZvcmUgfSA9IHN0bXQucGFyZW50Lm5vZGUucmF3cztcbiAgICAgICAgICAgIGlmIChzdG10LnR5cGUgPT09IFwibm9kZXNcIikgc3RtdC5ub2Rlc1swXS5yYXdzLmJlZm9yZSA9IGJlZm9yZTtcbiAgICAgICAgICAgIGVsc2Ugc3RtdC5ub2RlLnJhd3MuYmVmb3JlID0gYmVmb3JlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RtdC50eXBlID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgIHN0bXQubm9kZXNbMF0ucmF3cy5iZWZvcmUgPSBzdG10Lm5vZGVzWzBdLnJhd3MuYmVmb3JlIHx8IFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwbHlNZWRpYShidW5kbGUpIHtcbiAgICAgICAgYnVuZGxlLmZvckVhY2goc3RtdCA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCFzdG10Lm1lZGlhLmxlbmd0aCAmJiAhc3RtdC5sYXllci5sZW5ndGgpIHx8XG4gICAgICAgICAgICBzdG10LnR5cGUgPT09IFwiY2hhcnNldFwiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RtdC50eXBlID09PSBcImltcG9ydFwiKSB7XG4gICAgICAgICAgICBzdG10Lm5vZGUucGFyYW1zID0gYCR7c3RtdC5mdWxsVXJpfSAke3N0bXQubWVkaWEuam9pbihcIiwgXCIpfWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG10LnR5cGUgPT09IFwibWVkaWFcIikge1xuICAgICAgICAgICAgaWYgKHN0bXQubGF5ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxheWVyTm9kZSA9IGF0UnVsZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJsYXllclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogc3RtdC5sYXllci5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIgIT09IFwiXCIpLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc3RtdC5ub2RlLnNvdXJjZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0bXQucGFyZW50TWVkaWE/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lZGlhTm9kZSA9IGF0UnVsZSh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm1lZGlhXCIsXG4gICAgICAgICAgICAgICAgICBwYXJhbXM6IHN0bXQucGFyZW50TWVkaWEuam9pbihcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgc291cmNlOiBzdG10Lm5vZGUuc291cmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWVkaWFOb2RlLmFwcGVuZChsYXllck5vZGUpO1xuICAgICAgICAgICAgICAgIGxheWVyTm9kZS5hcHBlbmQoc3RtdC5ub2RlKTtcbiAgICAgICAgICAgICAgICBzdG10Lm5vZGUgPSBtZWRpYU5vZGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJOb2RlLmFwcGVuZChzdG10Lm5vZGUpO1xuICAgICAgICAgICAgICAgIHN0bXQubm9kZSA9IGxheWVyTm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RtdC5ub2RlLnBhcmFtcyA9IHN0bXQubWVkaWEuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSBzdG10O1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IG5vZGVzWzBdO1xuXG4gICAgICAgICAgICBsZXQgb3V0ZXJBdFJ1bGU7XG4gICAgICAgICAgICBsZXQgaW5uZXJBdFJ1bGU7XG4gICAgICAgICAgICBpZiAoc3RtdC5tZWRpYS5sZW5ndGggJiYgc3RtdC5sYXllci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVkaWFOb2RlID0gYXRSdWxlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm1lZGlhXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBzdG10Lm1lZGlhLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHBhcmVudC5zb3VyY2UsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGxheWVyTm9kZSA9IGF0UnVsZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJsYXllclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogc3RtdC5sYXllci5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIgIT09IFwiXCIpLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogcGFyZW50LnNvdXJjZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbWVkaWFOb2RlLmFwcGVuZChsYXllck5vZGUpO1xuICAgICAgICAgICAgICBpbm5lckF0UnVsZSA9IGxheWVyTm9kZTtcbiAgICAgICAgICAgICAgb3V0ZXJBdFJ1bGUgPSBtZWRpYU5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0bXQubWVkaWEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lZGlhTm9kZSA9IGF0UnVsZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtZWRpYVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogc3RtdC5tZWRpYS5qb2luKFwiLCBcIiksXG4gICAgICAgICAgICAgICAgc291cmNlOiBwYXJlbnQuc291cmNlLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpbm5lckF0UnVsZSA9IG1lZGlhTm9kZTtcbiAgICAgICAgICAgICAgb3V0ZXJBdFJ1bGUgPSBtZWRpYU5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0bXQubGF5ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxheWVyTm9kZSA9IGF0UnVsZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJsYXllclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogc3RtdC5sYXllci5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIgIT09IFwiXCIpLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogcGFyZW50LnNvdXJjZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaW5uZXJBdFJ1bGUgPSBsYXllck5vZGU7XG4gICAgICAgICAgICAgIG91dGVyQXRSdWxlID0gbGF5ZXJOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGVzWzBdLCBvdXRlckF0UnVsZSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBub2Rlc1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYmV0dGVyIG91dHB1dFxuICAgICAgICAgICAgbm9kZXNbMF0ucmF3cy5iZWZvcmUgPSBub2Rlc1swXS5yYXdzLmJlZm9yZSB8fCBcIlxcblwiO1xuXG4gICAgICAgICAgICAvLyB3cmFwIG5ldyBydWxlcyB3aXRoIG1lZGlhIHF1ZXJ5IGFuZC9vciBsYXllciBhdCBydWxlXG4gICAgICAgICAgICBpbm5lckF0UnVsZS5hcHBlbmQobm9kZXMpO1xuXG4gICAgICAgICAgICBzdG10LnR5cGUgPSBcIm1lZGlhXCI7XG4gICAgICAgICAgICBzdG10Lm5vZGUgPSBvdXRlckF0UnVsZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG10Lm5vZGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVzKGJ1bmRsZSwgc3R5bGVzKSB7XG4gICAgICAgIHN0eWxlcy5ub2RlcyA9IFtdO1xuXG4gICAgICAgIC8vIFN0cmlwIGFkZGl0aW9uYWwgc3RhdGVtZW50cy5cbiAgICAgICAgYnVuZGxlLmZvckVhY2goc3RtdCA9PiB7XG4gICAgICAgICAgaWYgKFtcImNoYXJzZXRcIiwgXCJpbXBvcnRcIiwgXCJtZWRpYVwiXS5pbmNsdWRlcyhzdG10LnR5cGUpKSB7XG4gICAgICAgICAgICBzdG10Lm5vZGUucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3R5bGVzLmFwcGVuZChzdG10Lm5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RtdC50eXBlID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgIHN0bXQubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHN0eWxlcy5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZVN0eWxlcyhyZXN1bHQsIHN0eWxlcywgb3B0aW9ucywgc3RhdGUsIG1lZGlhLCBsYXllcikge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnRzID0gcGFyc2VTdGF0ZW1lbnRzKHJlc3VsdCwgc3R5bGVzKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0YXRlbWVudHMpXG4gICAgICAgICAgLnRoZW4oc3RtdHMgPT4ge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyBlYWNoIHN0YXRlbWVudCBpbiBzZXJpZXNcbiAgICAgICAgICAgIHJldHVybiBzdG10cy5yZWR1Y2UoKHByb21pc2UsIHN0bXQpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RtdC5tZWRpYSA9IGpvaW5NZWRpYShtZWRpYSwgc3RtdC5tZWRpYSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgc3RtdC5wYXJlbnRNZWRpYSA9IG1lZGlhO1xuICAgICAgICAgICAgICAgIHN0bXQubGF5ZXIgPSBqb2luTGF5ZXIobGF5ZXIsIHN0bXQubGF5ZXIgfHwgW10pO1xuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBwcm90b2NvbCBiYXNlIHVyaSAocHJvdG9jb2w6Ly91cmwpIG9yIHByb3RvY29sLXJlbGF0aXZlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc3RtdC50eXBlICE9PSBcImltcG9ydFwiIHx8XG4gICAgICAgICAgICAgICAgICAvXig/OlthLXpdKzopP1xcL1xcLy9pLnRlc3Qoc3RtdC51cmkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKHN0bXQudXJpKSkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWQgYnkgZmlsdGVyXG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUltcG9ydElkKHJlc3VsdCwgc3RtdCwgb3B0aW9ucywgc3RhdGUpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYnVuZGxlID0gW107XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUNoYXJzZXQoc3RtdCkge1xuICAgICAgICAgICAgICBpZiAoIWNoYXJzZXQpIGNoYXJzZXQgPSBzdG10O1xuICAgICAgICAgICAgICAvLyBjaGFyc2V0cyBhcmVuJ3QgY2FzZS1zZW5zaXRpdmUsIHNvIGNvbnZlcnQgdG8gbG93ZXIgY2FzZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0bXQubm9kZS5wYXJhbXMudG9Mb3dlckNhc2UoKSAhPT1cbiAgICAgICAgICAgICAgICBjaGFyc2V0Lm5vZGUucGFyYW1zLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgYEluY29tcGF0YWJsZSBAY2hhcnNldCBzdGF0ZW1lbnRzOlxuICAke3N0bXQubm9kZS5wYXJhbXN9IHNwZWNpZmllZCBpbiAke3N0bXQubm9kZS5zb3VyY2UuaW5wdXQuZmlsZX1cbiAgJHtjaGFyc2V0Lm5vZGUucGFyYW1zfSBzcGVjaWZpZWQgaW4gJHtjaGFyc2V0Lm5vZGUuc291cmNlLmlucHV0LmZpbGV9YFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzcXVhc2ggc3RhdGVtZW50cyBhbmQgdGhlaXIgY2hpbGRyZW5cbiAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChzdG10ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gXCJjaGFyc2V0XCIpIGhhbmRsZUNoYXJzZXQoc3RtdCk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHN0bXQudHlwZSA9PT0gXCJpbXBvcnRcIikge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICBzdG10LmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJpbXBvcnRcIikgaW1wb3J0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gXCJjaGFyc2V0XCIpIGhhbmRsZUNoYXJzZXQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGJ1bmRsZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJldHRlciBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSBjaGlsZC5wYXJlbnQgPSBzdG10O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGltcG9ydHMucHVzaChzdG10KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdG10LnR5cGUgPT09IFwibWVkaWFcIiB8fCBzdG10LnR5cGUgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgIGJ1bmRsZS5wdXNoKHN0bXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNoYXJzZXRcbiAgICAgICAgICAgICAgPyBbY2hhcnNldCwgLi4uaW1wb3J0cy5jb25jYXQoYnVuZGxlKV1cbiAgICAgICAgICAgICAgOiBpbXBvcnRzLmNvbmNhdChidW5kbGUpXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZUltcG9ydElkKHJlc3VsdCwgc3RtdCwgb3B0aW9ucywgc3RhdGUpIHtcbiAgICAgICAgY29uc3QgYXRSdWxlID0gc3RtdC5ub2RlO1xuICAgICAgICBsZXQgc291cmNlRmlsZTtcbiAgICAgICAgaWYgKGF0UnVsZS5zb3VyY2U/LmlucHV0Py5maWxlKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IGF0UnVsZS5zb3VyY2UuaW5wdXQuZmlsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlID0gc291cmNlRmlsZVxuICAgICAgICAgID8gcGF0aC5kaXJuYW1lKGF0UnVsZS5zb3VyY2UuaW5wdXQuZmlsZSlcbiAgICAgICAgICA6IG9wdGlvbnMucm9vdDtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucmVzb2x2ZShzdG10LnVyaSwgYmFzZSwgb3B0aW9ucykpXG4gICAgICAgICAgLnRoZW4ocGF0aHMgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkgcGF0aHMgPSBbcGF0aHNdO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZWFjaCBwYXRoIGlzIGFic29sdXRlOlxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBwYXRocy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwYXRoLmlzQWJzb2x1dGUoZmlsZSlcbiAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZUlkKGZpbGUsIGJhc2UsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICA6IGZpbGVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKHJlc29sdmVkID0+IHtcbiAgICAgICAgICAgIC8vIEFkZCBkZXBlbmRlbmN5IG1lc3NhZ2VzOlxuICAgICAgICAgICAgcmVzb2x2ZWQuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVwZW5kZW5jeVwiLFxuICAgICAgICAgICAgICAgIHBsdWdpbjogXCJwb3N0Y3NzLWltcG9ydFwiLFxuICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBzb3VyY2VGaWxlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIHJlc29sdmVkLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEltcG9ydENvbnRlbnQocmVzdWx0LCBzdG10LCBmaWxlLCBvcHRpb25zLCBzdGF0ZSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAvLyBNZXJnZSBsb2FkZWQgc3RhdGVtZW50c1xuICAgICAgICAgICAgc3RtdC5jaGlsZHJlbiA9IHJlc3VsdC5yZWR1Y2UoKHJlc3VsdCwgc3RhdGVtZW50cykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cyA/IHJlc3VsdC5jb25jYXQoc3RhdGVtZW50cykgOiByZXN1bHRcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2FkSW1wb3J0Q29udGVudChyZXN1bHQsIHN0bXQsIGZpbGVuYW1lLCBvcHRpb25zLCBzdGF0ZSkge1xuICAgICAgICBjb25zdCBhdFJ1bGUgPSBzdG10Lm5vZGU7XG4gICAgICAgIGNvbnN0IHsgbWVkaWEsIGxheWVyIH0gPSBzdG10O1xuICAgICAgICBsYXllci5mb3JFYWNoKChsYXllclBhcnQsIGkpID0+IHtcbiAgICAgICAgICBpZiAobGF5ZXJQYXJ0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lTGF5ZXIpIHtcbiAgICAgICAgICAgICAgbGF5ZXJbaV0gPSBvcHRpb25zXG4gICAgICAgICAgICAgICAgLm5hbWVMYXllcihzdGF0ZS5hbm9ueW1vdXNMYXllckNvdW50ZXIrKywgc3RhdGUucm9vdEZpbGVuYW1lKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgYXRSdWxlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBXaGVuIHVzaW5nIGFub255bW91cyBsYXllcnMgaW4gQGltcG9ydCB5b3UgbXVzdCBhbHNvIHNldCB0aGUgXCJuYW1lTGF5ZXJcIiBwbHVnaW4gb3B0aW9uYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwRHVwbGljYXRlcykge1xuICAgICAgICAgIC8vIHNraXAgZmlsZXMgYWxyZWFkeSBpbXBvcnRlZCBhdCB0aGUgc2FtZSBzY29wZVxuICAgICAgICAgIGlmIChzdGF0ZS5pbXBvcnRlZEZpbGVzW2ZpbGVuYW1lXT8uW21lZGlhXT8uW2xheWVyXSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2F2ZSBpbXBvcnRlZCBmaWxlcyB0byBza2lwIHRoZW0gbmV4dCB0aW1lXG4gICAgICAgICAgaWYgKCFzdGF0ZS5pbXBvcnRlZEZpbGVzW2ZpbGVuYW1lXSkge1xuICAgICAgICAgICAgc3RhdGUuaW1wb3J0ZWRGaWxlc1tmaWxlbmFtZV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdGF0ZS5pbXBvcnRlZEZpbGVzW2ZpbGVuYW1lXVttZWRpYV0pIHtcbiAgICAgICAgICAgIHN0YXRlLmltcG9ydGVkRmlsZXNbZmlsZW5hbWVdW21lZGlhXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5pbXBvcnRlZEZpbGVzW2ZpbGVuYW1lXVttZWRpYV1bbGF5ZXJdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKSkudGhlbihcbiAgICAgICAgICBjb250ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChjb250ZW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXN1bHQud2FybihgJHtmaWxlbmFtZX0gaXMgZW1wdHlgLCB7IG5vZGU6IGF0UnVsZSB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraXAgcHJldmlvdXMgaW1wb3J0ZWQgZmlsZXMgbm90IGNvbnRhaW5pbmcgQGltcG9ydCBydWxlc1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhhc2hGaWxlc1tjb250ZW50XT8uW21lZGlhXT8uW2xheWVyXSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NDb250ZW50KFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICBwb3N0Y3NzXG4gICAgICAgICAgICApLnRoZW4oaW1wb3J0ZWRSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBpbXBvcnRlZFJlc3VsdC5yb290O1xuICAgICAgICAgICAgICByZXN1bHQubWVzc2FnZXMgPSByZXN1bHQubWVzc2FnZXMuY29uY2F0KGltcG9ydGVkUmVzdWx0Lm1lc3NhZ2VzKTtcblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5za2lwRHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0ltcG9ydCA9IHN0eWxlcy5zb21lKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIGNoaWxkLm5hbWUgPT09IFwiaW1wb3J0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0ltcG9ydCkge1xuICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBoYXNoIGZpbGVzIHRvIHNraXAgdGhlbSBuZXh0IHRpbWVcbiAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGFzaEZpbGVzW2NvbnRlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmhhc2hGaWxlc1tjb250ZW50XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oYXNoRmlsZXNbY29udGVudF1bbWVkaWFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmhhc2hGaWxlc1tjb250ZW50XVttZWRpYV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHN0YXRlLmhhc2hGaWxlc1tjb250ZW50XVttZWRpYV1bbGF5ZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyByZWN1cnNpb246IGltcG9ydCBAaW1wb3J0IGZyb20gaW1wb3J0ZWQgZmlsZVxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdHlsZXMocmVzdWx0LCBzdHlsZXMsIG9wdGlvbnMsIHN0YXRlLCBtZWRpYSwgbGF5ZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG4gIH1cbn1cblxuQXRJbXBvcnQucG9zdGNzcyA9IHRydWU7XG5cbnZhciBwb3N0Y3NzSW1wb3J0ID0gQXRJbXBvcnQ7XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcbiAgX19wcm90b19fOiBudWxsLFxuICAnZGVmYXVsdCc6IHBvc3Rjc3NJbXBvcnRcbn0sIFtwb3N0Y3NzSW1wb3J0XSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-9deb2354.js\n");

/***/ })

}]);